{"name":"pLCM++","tagline":"A fast and multi-threaded implementation of the LCM algorithm.","body":"pLCM++ is a fast and multi-threaded C++ implementation of the LCM (Linear Closed itemsets Miner) algorithm (see [1], [2]).\r\n\r\n## Performance\r\n- pLCM++ is usually around 3 times faster than [jLCM](https://github.com/martinkirch/jlcm) on common datasets\r\n(main improvements over jLCM are described below)\r\n- when limited to 1 thread (i.e. using the command line option `-t 1`),\r\nthe performance of pLCM++ is usually similar to the one of [LCM 2.5](http://research.nii.ac.jp/~uno/code/lcm25.zip),\r\nthe fastest mono-threaded implementation proposed by T. Uno. \r\n\r\nNote: performance must be measured using option `-b` (benchmark mode), which disables online printing of patterns.\r\n\r\n## Compiling and running pLCM++\r\n\r\nUse `make` to build:\r\n\r\n```\r\ncd src\r\nmake\r\n```\r\n\r\nRun `./pLCM++ --help` for usage details.\r\n\r\nThis tool uses ASCII files as input: each line represents a transaction. You may find example input files in the [FIMI repository](http://fimi.ua.ac.be/data/).\r\n\r\n## History\r\n\r\nIt started as a port of [jLCM](https://github.com/martinkirch/jlcm) to C++.\r\njLCM is a parallel implementation of the LCM algorithm, in java, \r\nand was mostly written by Martin Kirchgessner and Vincent Leroy.\r\n\r\n## License and copyright owners\r\n\r\nThis work is released under the Apache License 2.0 (see LICENSE).\r\n\r\nCopyright 2013 Etienne Dublé, Martin Kirchgessner, Vincent Leroy, Alexandre Termier, \r\nCNRS and Université Joseph Fourier.\r\n\r\n\r\n## Improvements over jLCM\r\n\r\nAfter the initial porting phase, pLCM++ received a set of \r\noptimizations. Main ones are:\r\n- Use of minimal integer types in the processing part, not only\r\nfor storage (as it was in [jLCM](https://github.com/martinkirch/jlcm)). This allows more optimization\r\nopportunities for the compiler.\r\n- Improved dataset reduction algorithm: pLCM++ uses hashes in \r\norder to find which transactions can be merged together.\r\n- Prefer range-based over java-style iterators (i.e. provide \r\nstart and end of a range instead of an abstract Iterator object\r\nwith methods hasNext() and next()). This is obviously faster,\r\nbut it required algorithmic changes in order to provide contiguous\r\nranges when possible.\r\n\r\n## Reference papers\r\n\r\n[1] \"An efficient algorithm for enumerating closed patterns in transaction \r\ndatabases\" by T. Uno, T. Asai, Y. Uchida and H. Arimura, in Discovery Science, \r\n2004\r\n\r\n[2] \"Discovering closed frequent itemsets on multicore: Parallelizing computations \r\nand optimizing memory accesses\" by B. Negrevergne, A. Termier, J-F. Mehaut, \r\nand T. Uno in International Conference on High Performance Computing & \r\nSimulation, 2010\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}